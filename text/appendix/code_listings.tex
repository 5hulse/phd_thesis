\chapter{\textsc{Python} Listings}
\label{chap:code-listings}

Presented here are listings of \Python implementations for a number of
the routines described in this text. These can be thought of minimalist
versions of code present in \ac{EsPy} package. These listings require
\Python version 3.8 or higher, and also require the \texttt{numpy} and
\texttt{scipy} packages to be installed from the \ac{PyPI}. As a preliminary,
\cref{lst:imports} outlines all the necessary imports for the subsequent
listings in this chapter.

\mylisting{python3}{code_listings/imports.py}{%
    The required imports for the subsequent \Python listings in
    \cref{chap:code-listings}.
}{
    The required imports for the subsequent listings in this chapter.
    The \mintinline{python3}{itertools.product} function is used in the
    \acs{MMEMPM} routine (\cref{lst:mmempm}).
    The imports from the \mintinline{python3}{typing} module are used to
    annotate what the expected argument- and return-types are.
    The \mintinline{python3}{numpy} and \mintinline{python3}{scipy} modules are
    ubiquitous, providing access to efficient routines for numerical
    computations.
}{lst:imports}

\section{Matrix Pencil Methods}
\subsection{\acs{MDL}}
\mylisting{python3}{code_listings/mdl.py}{%
A \Python implementation of the \acl{MDL} for estimating the model order
of a \acs{1D} \acs{FID}.
}{%
The \acs{MDL} for estimation of the model order of a \acs{1D} \acs{FID}.
The first relative minimum in \mintinline{python}{mdl_vec} is determined to be
the estimate of $M$, rather than the global minimum (Line \ref{ln:argmin}; see
\cref{fn:argrelmin} in \cref{subsec:model-order}).
}{lst:mdl}

\subsection{\acs{MPM}}
\mylisting{python3}{code_listings/mpm.py}{
A \Python implementation of the \acl{MPM} for \acs{1D} \acs{FID} estimation.
}{
The \acs{MPM} for \acs{1D} \ac{FID} estimation, with the option of
predicting the model order using the \acs{MDL}.
}{lst:mpm}

\subsection{\acs{MMEMPM}}
\mylisting{python3}{code_listings/mmempm.py}{
A \Python implementation of the \acl{MMEMPM} for \acs{2D} hypercomplex
\acs{FID} estimation.
}{
The \acs{MMEMPM} for \acs{2D} hypercomplex \acs{FID} estimation. Due
to the very large size of the Hankel matrix $\symbf{E}_{\bY}$, a truncated
\acs{SVD} routine is employed, which determines only the first $M$
components of the decomposition. This is only available to arrays stored in
sparse form in \textsc{SciPy} (Lines \ref{ln:sparse1}--\ref{ln:sparse2}; see
\cref{fn:sparse-svd} in \cref{subsec:mpm-profiling}).
}{lst:mmempm}

\section{Non-Linear Programming}
\subsection{Trust Region Algorithm}

\mylisting{python3}{code_listings/trust_region.py}{
A \Python implementation of the \acl{ST} trust region algorithm.
}{
The \acl{ST} trust region algorithm. Included is a check for oscillators with
negative amplitudes, which causes the routine to terminate in order for said
oscillators to be purged (Lines \ref{ln:negamp1}--\ref{ln:negamp2}).
}{lst:tr}

\subsection{Computing
    \texorpdfstring{$\mathcal{F}_{\phi}$}{F},
    \texorpdfstring{$\nabla \mathcal{F}_{\phi}$}{grad}, and
    \texorpdfstring{$\nabla^2 \mathcal{F}_{\phi}$}{hess}
}

\mylisting{python3}{code_listings/obj_grad_hess.py}{
A \Python implementation for generating the fidelity, and its gradient and
Hessian, as part of the \acl{NLP} routine.
}{
Code for generating the fidelity, gradient and Hessian as
part of the \acl{NLP} routine for \ac{1D} \acp{FID}.
The \mintinline{python3}{FunctionFactory} object accepts a parameter
set (\mintinline{python3}{theta}) and function (\mintinline{python3}{fun}),
which computes the objective, gradient and Hessian. The first time a quantity
is requested from the factory, the objective and its
derivatives are computed and cached (memoised), such that the next time a
quantity is requested, the cached result is returned, rather than requiring the
expensive function to be re-run.
\mintinline{python3}{FunctionFactory1D} (Lines
\ref{ln:ff1}--\ref{ln:ff2}) inherits from the base class, for specific use in
\ac{1D} estimation.
For the equivalent code for \ac{2D} estimation, and/or for computing the
approximated Hessian instead, the reader is directed to the
\protect\path{nlp/_funcs.py} module in the \ac{EsPy} package.
}{lst:obj-grad-hess}

\subsection{The Main Routine}

\mylisting{python3}{code_listings/nlp_routine.py}{
    A \Python implementation for running the \acl{NLP} routine.
}{
    Code which runs the \acs{NLP} routine for \acs{FID} estimation. The
    routine consists of running the \ac{ST} algorithm (\cref{lst:tr})
    until it returns a parameter array without negative amplitudes. If negative
    amplitudes are present, the corresponding oscillators are removed, and the
    \ac{ST} algorithm is re-run.
}{lst:nlp}

\section{\acs{CUPID}}

\subsection{Assigning Multiplet Structures}

\mylisting{python3}{code_listings/mp_assign.py}{
A \Python implementation which performs multiplet assignment as part of
\acs{CUPID}.
}{
    Code which performs multiplet assignment as part of \acs{CUPID}.
}{lst:mp-assign}
