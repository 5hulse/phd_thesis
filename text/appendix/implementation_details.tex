\chapter{Code Listings}

\note{NEED TO ADD TEXT TO DESCRIBE THINGS}
The following is all the required imports:
\pylisting{code_listings/imports.py}

\section{\Aclp{MPM}}

\subsection{\acs{MDL}}
The \mintinline{python}{mdl} function computes an estimate of the number of
oscillators present in a \ac{1D} \iac{FID} (Section \ref{subsec:model-order}).
The first relative minimum in \mintinline{python}{mdl_vec} is determined to be
the estimate of $M$, rather than the global minimum, since the presence of very
small singular values can lead to division errors.\note{More precise here?}
\pylisting{code_listings/mdl.py}

\subsection{\acs{MPM}}
\pylisting{code_listings/mpm.py}

\subsection{\acs{MMEMPM}}
\pylisting{code_listings/mmempm.py}

\section{\ac{NLP}}

\subsection{Trust Region Algorithm}

\pylisting{code_listings/trust_region.py}

\subsection{Computing
    \texorpdfstring{$\mathcal{F}_{\phi}$}{F},
    \texorpdfstring{$\nabla \mathcal{F}_{\phi}$}{grad}, and
    \texorpdfstring{$\nabla^2 \mathcal{F}_{\phi}$}{hess}
}

\pylisting{code_listings/obj_grad_hess.py}

\subsection{The main routine}

\pylisting{code_listings/nlp_routine.py}

% A bunch of Python code listings illustrating how certain things described in
% the main text are implemented.

% \subsection{Computing the gradient and Hessian for non-linear programming}

% In this section, a description of how the fidelity, its gradient, and its
% Hessian (Equation \ref{eq:fidelity-grad-hess}) are computed is provided.

% \pylisting{code_listings/obj_grad_hess/definition.py}

% We will start by constructing the model array $\bx$. It is necessary to know
% the form of each oscillator in $\bx$ to compute its derivatives.
% \begin{subequations}
%     \begin{gather}
%         \bx = \exp\left(\symbf{Z}\right) \symbf{\alpha},\\
%         \symbf{Z} = \symbf{\tau} \otimes \symbf{z},\\
%         \symbf{\tau}\left[n\right] = (n-1)\Dt\ \forall n \in \lbrace0, \cdots, N - 1\rbrace\\
%         \symbf{z}\left[m\right] = 2 \pi \iu f_m- \eta_m\ \forall m \in \lbrace 1, \cdots, M \rbrace\\
%         \symbf{\alpha}\left[m\right] = a_m \exp\left(\iu \phi_m\right)
%     \end{gather}
% \end{subequations}
% Therefore a $\mathbb{C}^{N \times M}$ array $\bX_m$ is created, such that
% \begin{equation}
%     \bX_m = \exp\left(\symbf{Z}\right) * \alpha
% \end{equation}
% \nomenclature[M]{$*$}{Broadcasting notation, as is commonly performed in
% numerical computations. See
% \href{https://numpy.org/doc/stable/user/basics.broadcasting.html}{this page of
% the NumPy documentation} for details}


% \pylisting{code_listings/obj_grad_hess/x_per_osc.py}


% \subsection{Multiplet prediction}
% \label{sec:multiplet prediction}

% \pylisting{code_listings/multiplet_prediction.py}
